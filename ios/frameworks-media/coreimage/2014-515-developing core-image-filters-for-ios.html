<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>2014-515-developing core-image-filters-for-ios</title>
</head>

<body>
<h1>2014-515-developing core-image-filters-for-ios</h1>
<p>&nbsp;</p>
<p>Alexandre Naaman</p>
<p>Tony Chu</p>
<p>&nbsp;</p>
<p>Concepts</p>
<p>Examples of writing custom kernels</p>
<p>Platform differences</p>
<p>&nbsp;</p>
<h2>Key Concepts [1:50]</h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>CIKernel</td>
    <td>Represents a program written in Core Image's kernel language</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>CIFilter</td>
    <td><p>Has mutable input parameters</p>
    <p>Uses one or more CIKernels to make new image based on inputs</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>CIImage</td>
    <td><p>An immutable object that represents the recipe for an image</p>
    <p>Non zero origin and possibly infinite bounds</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>CIContext</td>
    <td>An object through which Core Image draws results</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>Workflow</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Color Kernels [7:50]</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>kernel vec4 doNothing( __sample s) { return s.rgba; }</p>
<p>kernel vec4 swapRedAndGreen (__sample s) { return s.grba; }</p>
<p>kernel vec4 swapRedAndGreen(__sample s, float amount) { return mix(s.rgba, s.grba, amount);}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Color Kernel Which Depends on Position [12]</p>
<p>Vignette effect</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>centerOffset = extent.origin + extent.size/2.0</p>
      <p>radius = length(extent.size)/2.0</p>
      <p>kernel vec4 vignette (__sample s, vec2 centerOffset, float radius ) {</p>
      <p>vec2 vecFromCenter = destCoord() - centerOffset;</p>
      <p>float distance = length(vecFromCenter)</p>
      <p>float darken = 1.0 - (distance / radius)</p>
      <p>return vec4(s.rgb * darken, s.a)</p>
    <p>}</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Filter</td>
    <td><p>- outputImage {</p>
    <p>let dod: CGRect = inputImage.extent</p>
    <p>let radius : double = 0.5 * hypot(dod.size.width, dod.size.height)</p>
    <p>let centerOffset : CIVector = CIV</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<h2>Wrap Kernel [16:30]</h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>kernel vec2 doNothing() { return destCoord() }</p>
      <p>kernel vec2 mirrorX(float imageWidth) {</p>
      <p>vec2 input = destCoord();</p>
      <p>return vec2(imageWidth - input.x , input.y); </p>
    <p>}</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>CIKernel</td>
    <td>CIColorKernel</td>
    <td>CIWrapKernel</td>
  </tr>
  <tr>
    <td># Input images</td>
    <td>0..n</td>
    <td>0..n</td>
    <td>1</td>
  </tr>
  <tr>
    <td>Input Type</td>
    <td>sampler</td>
    <td>__sample</td>
    <td>destCoord()</td>
  </tr>
  <tr>
    <td>Access</td>
    <td>sample(...)</td>
    <td>vec4</td>
    <td>vec2</td>
  </tr>
  <tr>
    <td>Ouput Image</td>
    <td>vec4</td>
    <td>vec4</td>
    <td>vec2</td>
  </tr>
  <tr>
    <td>DOD</td>
    <td>YES</td>
    <td>YES</td>
    <td>YES</td>
  </tr>
  <tr>
    <td>ROI</td>
    <td>YES</td>
    <td>NO</td>
    <td>YES</td>
  </tr>
</table>
<h2>General Kernels - CIKernel - Tony Chu [31:20]</h2>
<p>When to write a general kernel?</p>
<ul>
  <li>Kernel needs multiple samples of an image
    <ul>
      <li>e.g., any kind of blur or convolution filter</li>
    </ul>
  </li>
  <li>Kernel contains a dependent texture read
    <ul>
      <li>e.g., sample from image A used to determine where to sample from image B</li>
    </ul>
  </li>
</ul>
<p>kernel vec4 do_nothing(sampler image) {</p>
<p>vec2 dc = destCoord();</p>
<p>return sample(image, samplerTransform(image, dc));</p>
<p>}</p>
<p>return sample(image, samplerCoord(image)); // equally to below 2 lines</p>
<p>&nbsp;</p>
<p>Destination space vs. Sampler space</p>
<p>&nbsp;</p>
<p>kernel vec4 motionBlur(sampler image, vec2 velocity) {</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<h2>Platform differences / Portability of General Kernels [43]</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Performance Considerations</p>
<p>&nbsp;</p>
</body>
</html>
