<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>FloatingPointType-ref</title>
</head>

<body>
<h1>FloatingPointType-ref
</h1>
<p>&nbsp;</p>
<h2>Supers</h2>
<p>protocol FloatingPointType : Strideable</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Subs</h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>struct Float</td>
    <td>struct Double</td>
    <td>struct Float80</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>/// Create an instance initialized to zero.<br />
      init()</p>
      <p> /// Create an instance initialized to `value`.<br />
    init(_ value: Float)</p></td>
    <td><p>/// Create an instance initialized to zero.<br />
      init()</p>
      <p> /// Create an instance initialized to `value`.<br />
    init(_ value: Double)</p></td>
    <td><p>/// Create an instance initialized to zero.<br />
      init()</p>
      <p> /// Create an instance initialized to `value`.<br />
    init(_ value: Float80)</p></td>
  </tr>
  <tr>
    <td>Printable</td>
    <td colspan="3">&nbsp;</td>
  </tr>
  <tr>
    <td>FloatingPointType</td>
    <td>&nbsp;</td>
    <td><p>/// The positive infinity.<br />
      static var infinity: Double { get }</p>
      <p> /// A quiet NaN.<br />
        static var NaN: Double { get }</p>
      <p> /// A quiet NaN.<br />
        static var quietNaN: Double { get }</p>
      <p> /// `true` iff `self` is negative<br />
        var isSignMinus: Bool { get }</p>
      <p> /// `true` iff `self` is normal (not zero, subnormal, infinity, or<br />
        /// NaN).<br />
        var isNormal: Bool { get }</p>
      <p> /// `true` iff `self` is zero, subnormal, or normal (not infinity<br />
        /// or NaN).<br />
        var isFinite: Bool { get }</p>
      <p> /// `true` iff `self` is +0.0 or -0.0.<br />
        var isZero: Bool { get }</p>
      <p> /// `true` iff `self` is subnormal.<br />
        var isSubnormal: Bool { get }</p>
      <p> /// `true` iff `self` is infinity.<br />
        var isInfinite: Bool { get }</p>
      <p> /// `true` iff `self` is NaN.<br />
        var isNaN: Bool { get }</p>
      <p> /// `true` iff `self` is a signaling NaN.<br />
    var isSignaling: Bool { get }</p></td>
    <td>NA</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td colspan="2">/// The IEEE 754 &quot;class&quot; of this type.<br />
    var floatingPointClass: FloatingPointClassification { get }</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>IntegerLiteralConvertible</td>
    <td colspan="3"><p>init(_builtinIntegerLiteral value: Builtin.Int2048)</p>
      <p> /// Create an instance initialized to `value`.<br />
    init(integerLiteral value: Int64)</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td colspan="2">init(_builtinFloatLiteral value: Builtin.FPIEEE80)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>FloatLiteralConvertible</td>
    <td>/// Create an instance initialized to `value`.<br />
init(floatLiteral value: Float)</td>
    <td>/// Create an instance initialized to `value`.<br />
init(floatLiteral value: Double)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Comparable</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Hashable</td>
    <td colspan="2">/// The hash value.<br />
      ///<br />
      /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`<br />
      ///<br />
      /// **Note:** the hash value is not guaranteed to be stable across<br />
      /// different invocations of the same program.  Do not persist the<br />
      /// hash value across program runs.<br />
    var hashValue: Int { get }</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>AbsoluteValuable</td>
    <td>/// Returns the absolute value of `x`<br />
static func abs(x: Float) -&gt; Float</td>
    <td>/// Returns the absolute value of `x`<br />
static func abs(x: Double) -&gt; Double</td>
    <td>/// Returns the absolute value of `x`<br />
    static func abs(x: Float80) -&gt; Float80</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>init(_ v: UInt8)<br />
      init(_ v: Int8)<br />
      init(_ v: UInt16)<br />
      init(_ v: Int16)<br />
      init(_ v: UInt32)<br />
      init(_ v: Int32)<br />
      init(_ v: UInt64)<br />
      init(_ v: Int64)<br />
      init(_ v: UInt)<br />
    init(_ v: Int)</p></td>
    <td><p> init(_ v: UInt8)<br />
      init(_ v: Int8)<br />
      init(_ v: UInt16)<br />
      init(_ v: Int16)<br />
      init(_ v: UInt32)<br />
      init(_ v: Int32)<br />
      init(_ v: UInt64)<br />
      init(_ v: Int64)<br />
      init(_ v: UInt)<br />
    init(_ v: Int)</p></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>/// Construct an instance that approximates `other`.<br />
      init(_ other: Double)</p>
      <p> /// Construct an instance that approximates `other`.<br />
    init(_ other: Float80)</p></td>
    <td><p>/// Construct an instance that approximates `other`.<br />
      init(_ other: Float)</p>
      <p> /// Construct an instance that approximates `other`.<br />
    init(_ other: Float80)</p></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Strideable</td>
    <td><p>/// Returns a stride `x` such that `self.advancedBy(x)` approximates<br />
      /// `other`.<br />
      ///<br />
      /// Complexity: O(1).<br />
      func distanceTo(other: Float) -&gt; Float</p>
      <p> /// Returns a `Self` `x` such that `self.distanceTo(x)` approximates<br />
        /// `n`.<br />
        ///<br />
        /// Complexity: O(1).<br />
    func advancedBy(amount: Float) -&gt; Float</p></td>
    <td><p>/// Returns a stride `x` such that `self.advancedBy(x)` approximates<br />
      /// `other`.<br />
      ///<br />
      /// Complexity: O(1).<br />
      func distanceTo(other: Double) -&gt; Double</p>
      <p> /// Returns a `Self` `x` such that `self.distanceTo(x)` approximates<br />
        /// `n`.<br />
        ///<br />
        /// Complexity: O(1).<br />
    func advancedBy(amount: Double) -&gt; Double</p></td>
    <td><p>/// Returns a stride `x` such that `self.advancedBy(x)` approximates<br />
      /// `other`.<br />
      ///<br />
      /// Complexity: O(1).<br />
      func distanceTo(other: Float80) -&gt; Float80</p>
      <p> /// Returns a `Self` `x` such that `self.distanceTo(x)` approximates<br />
        /// `n`.<br />
        ///<br />
        /// Complexity: O(1).<br />
    func advancedBy(amount: Float80) -&gt; Float80</p></td>
  </tr>
  <tr>
    <td>Reflectable</td>
    <td colspan="2">/// Returns a mirror that reflects `self`.<br />
func getMirror() -&gt; MirrorType</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>CVarArgType</td>
    <td colspan="2">/// Transform `self` into a series of machine words that can be<br />
      /// appropriately interpreted by C varargs<br />
    func encode() -&gt; [Word]</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
