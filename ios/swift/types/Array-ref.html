<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Array</title>
</head>

<body>
<h1>Array</h1>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>struct Array&lt;T&gt; : MutableCollectionType, Sliceable</td>
    <td><p>typealias Element = T<br />
      var startIndex: Int { get }<br />
      var endIndex: Int { get }<br />
      subscript (index: Int) -&gt; T<br />
      func generate() -&gt; IndexingGenerator&lt;[T]&gt;<br />
      typealias SubSlice = Slice&lt;T&gt;<br />
      subscript (subRange: Range&lt;Int&gt;) -&gt; Slice&lt;T&gt;</p>
      <p> /// Initialization from an existing buffer does not have &quot;array.init&quot;<br />
        /// semantics because the caller may retain an alias to buffer.<br />
    init(_ buffer: _ArrayBuffer&lt;T&gt;)</p></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array : ArrayLiteralConvertible</td>
    <td>static func convertFromArrayLiteral(elements: T...) -&gt; [T]</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array </td>
    <td><p>/// Construct an empty Array<br />
      init()<br />
      init&lt;S : SequenceType where T == T&gt;(_ s: S)</p>
      <p> /// Construct a Array of `count` elements, each initialized to<br />
        /// `repeatedValue`.<br />
        init(count: Int, repeatedValue: T)</p>
      <p> /// How many elements the Array stores<br />
        var count: Int { get }</p>
      <p> /// How many elements the `Array` can store without reallocation<br />
        var capacity: Int { get }</p>
      <p> /// `true` if and only if the `Array` is empty<br />
        var isEmpty: Bool { get }</p>
      <p> /// The first element, or `nil` if the array is empty<br />
        var first: T? { get }</p>
      <p> /// The last element, or `nil` if the array is empty<br />
        var last: T? { get }</p>
      <p> /// Ensure the array has enough mutable contiguous storage to store<br />
        /// minimumCapacity elements in.  Note: does not affect count.<br />
        /// Complexity: O(N)<br />
        mutating func reserveCapacity(minimumCapacity: Int)</p>
      <p> /// Append newElement to the Array in O(1) (amortized)<br />
        mutating func append(newElement: T)</p>
      <p> /// Append elements from `sequence` to the Array<br />
        mutating func extend&lt;S : SequenceType where T == T&gt;(sequence: S)</p>
      <p> /// Remove an element from the end of the Array in O(1).<br />
        /// Requires: count &gt; 0<br />
        mutating func removeLast() -&gt; T</p>
      <p> /// Insert an element at index `i` in O(N).  Requires: `i` &lt;=<br />
        /// `count`<br />
        mutating func insert(newElement: T, atIndex i: Int)</p>
      <p> /// Remove the element at the given index.  Worst case complexity:<br />
        /// O(N).  Requires: `index` &lt; `count`<br />
        mutating func removeAtIndex(index: Int) -&gt; T</p>
      <p> /// Erase all the elements.  If `keepCapacity` is `true`, `capacity`<br />
        /// will not change<br />
        mutating func removeAll(keepCapacity: Bool = default)<br />
        func join&lt;S : SequenceType where [T] == [T]&gt;(elements: S) -&gt; [T]<br />
        func reduce&lt;U&gt;(initial: U, combine: (U, T) -&gt; U) -&gt; U<br />
        mutating func sort(isOrderedBefore: (T, T) -&gt; Bool)<br />
        func sorted(isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T]</p>
      <p> /// Return an Array containing the results of calling<br />
        /// `transform(x)` on each element `x` of `self`<br />
        func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; [U]</p>
      <p> /// A Array containing the elements of `self` in reverse order<br />
        func reverse() -&gt; [T]</p>
      <p> /// Return an Array containing the elements `x` of `self` for which<br />
        /// `includeElement(x)` is `true`<br />
    func filter(includeElement: (T) -&gt; Bool) -&gt; [T]</p></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array : Reflectable</td>
    <td>func getMirror() -&gt; MirrorType</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array : Printable, DebugPrintable </td>
    <td>var description: String { get }<br />
var debugDescription: String { get }</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array</td>
    <td>/// Call body(p), where p is a pointer to the Array's contiguous storage<br />
func withUnsafeBufferPointer&lt;R&gt;(body: (UnsafeBufferPointer&lt;T&gt;) -&gt; R) -&gt; R<br />
mutating func withUnsafeMutableBufferPointer&lt;R&gt;(body: (inout UnsafeMutableBufferPointer&lt;T&gt;) -&gt; R) -&gt; R</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array</td>
    <td>/// This function &quot;seeds&quot; the ArrayLiteralConvertible protocol<br />
static func convertFromHeapArray(base: Builtin.RawPointer, owner: Builtin.NativeObject, count: Builtin.Word) -&gt; [T]</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array </td>
    <td>mutating func replaceRange&lt;C : CollectionType where T == T&gt;(subRange: Range&lt;Int&gt;, with newValues: C)<br />
mutating func splice&lt;S : CollectionType where T == T&gt;(s: S, atIndex i: Int)<br />
mutating func removeRange(subRange: Range&lt;Int&gt;)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Array </td>
    <td>/// Construct from the given `_CocoaArrayType`.  If `noCopy` is `true`,<br />
/// either `source` must be known to be immutable, or the resulting<br />
/// `Array` must not survive across code that could mutate `source`.<br />
init(_fromCocoaArray source: _CocoaArrayType, noCopy: Bool = default)</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
