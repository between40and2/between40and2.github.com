<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Untitled Document</title>
</head>

<body>
<h1>GeneratorType-ref</h1>
<p>&nbsp;</p>
<p>/// Encapsulates iteration state and interface for iteration over a *sequence*.<br />
  ///<br />
  /// **Note:** While it is safe to copy a *generator*, advancing one copy may invalidate the others.<br />
  ///<br />
  /// Any code that uses multiple generators (or `for`\ ...\ `in` loops) over a single *sequence* should have static knowledge that the specific *sequence* is multi-pass, either because its concrete type is known or because it is constrained to `CollectionType`. Also, the generators must be obtained by distinct calls to the *sequence's* `generate()` method, rather than by copying.<br />
protocol GeneratorType {</p>
<p> /// The type of element generated by `self`.<br />
  typealias Element</p>
<p> /// Advance to the next element and return it, or `nil` if no next<br />
  /// element exists.<br />
  ///<br />
  /// Requires: `next()` has not been applied to a copy of `self` since the copy was made, and no preceding call to `self.next()` has returned `nil`.  Specific implementations of this protocol are encouraged to respond to violations of this requirement by calling `preconditionFailure(&quot;...&quot;)`.<br />
  mutating func next() -&gt; Element?<br />
  }</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>structs comfonance only GeneratorType</h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>struct DictionaryGenerator&lt;Key : Hashable, Value&gt; : GeneratorType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>struct StrideThroughGenerator&lt;T : Strideable&gt; : GeneratorType</td>
    <td>&nbsp;</td>
    <td>struct StrideThrough&lt;T : Strideable&gt; : SequenceType</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>struct StrideToGenerator&lt;T : Strideable&gt; : GeneratorType</td>
    <td>&nbsp;</td>
    <td>struct StrideTo&lt;T : Strideable&gt; : SequenceType</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>struct ZipGenerator2&lt;E0 : GeneratorType, E1 : GeneratorType&gt; : GeneratorType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<h2>both GeneratorType and SequenceType</h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>clients</td>
  </tr>
  <tr>
    <td>struct EmptyGenerator&lt;T&gt; : GeneratorType, SequenceType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>struct EmptyCollection&lt;T&gt; : CollectionType</td>
  </tr>
  <tr>
    <td>struct EnumerateGenerator&lt;Base : GeneratorType&gt; : GeneratorType, SequenceType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>struct EnumerateSequence&lt;Base : SequenceType&gt; : SequenceType</td>
  </tr>
  <tr>
    <td>struct FilterGenerator&lt;Base : GeneratorType&gt; : GeneratorType, SequenceType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>struct FilterCollectionView&lt;Base : CollectionType&gt; : CollectionType</p>
    <p>struct FilterSequenceView&lt;Base : SequenceType&gt; : SequenceType</p></td>
  </tr>
  <tr>
    <td>struct GeneratorOf&lt;T&gt; : GeneratorType, SequenceType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>struct SequenceOf&lt;T&gt; : SequenceType </td>
  </tr>
  <tr>
    <td>struct GeneratorOfOne&lt;T&gt; : GeneratorType, SequenceType </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>struct CollectionOfOne&lt;T&gt; : CollectionType </td>
  </tr>
  <tr>
    <td>struct GeneratorSequence&lt;G : GeneratorType&gt; : GeneratorType, SequenceType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>None</td>
  </tr>
  <tr>
    <td>struct IndexingGenerator&lt;C : _CollectionType&gt; : GeneratorType, SequenceType</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>struct Array&lt;T&gt; : MutableCollectionType, Sliceable</p>
      <p>struct BidirectionalReverseView&lt;T : CollectionType where T.Index : BidirectionalIndexType&gt; : CollectionType</p>
      <p>struct ContiguousArray&lt;T&gt; : MutableCollectionType, Sliceable</p>
      <p>struct RandomAccessReverseView&lt;T : CollectionType where T.Index : RandomAccessIndexType&gt; : CollectionType</p>
      <p>struct Repeat&lt;T&gt; : CollectionType </p>
    <p>struct Slice&lt;T&gt; : MutableCollectionType, Sliceable</p>
    <p>extension String : CollectionType</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
