<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Range (1.2)</title>
</head>

<body>
<p>// A collection of consecutive discrete index values.<br />
  ///<br />
  /// :param: `T` is both the element type and the index type of the  collection.<br />
  ///<br />
  /// Like other collections, a range containing one element has an `endIndex` that is the successor of its `startIndex`; and an empty range has `startIndex == endIndex`.<br />
  ///<br />
  /// Axiom: for any `Range` `r`, `r[i] == i`.<br />
  ///<br />
  /// Therefore, if `T` has a maximal value, it can serve as an `endIndex`, but can never be contained in a `Range&lt;T&gt;`.<br />
  ///<br />
  /// It also follows from the axiom above that `(-99..&lt;100)[0] == 0`. To prevent confusion (because some expect the result to be `-99`), in a context where `T` is known to be an integer type, subscripting with `T` is a compile-time error::<br />
  ///<br />
  ///   // error: could not find an overload for 'subscript'...<br />
  ///   println( Range&lt;Int&gt;(start:-99, end:100)[0] )<br />
  ///<br />
  /// However, subscripting that range still works in a generic context::<br />
  ///<br />
  ///   func brackets&lt;T:ForwardIndexType&gt;(x: Range&lt;T&gt;, i: T) -&gt; T {<br />
  ///     return x[i] // Just forward to subscript<br />
  ///   }<br />
///   println(brackets(Range&lt;Int&gt;(start:-99, end:100), 0)) // prints 0</p>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>struct Range&lt;T : ForwardIndexType&gt;</td>
    <td>&nbsp;</td>
    <td>struct _NSRange </td>
  </tr>
  <tr>
    <td><p>&nbsp;</p>
    <p>: Equatable, CollectionType, </p></td>
    <td>/// A type that represents a valid position in the collection.<br />
/// <br />
/// Valid indices consist of the position of every element and a<br />
/// &quot;past the end&quot; position that's not valid for use as a subscript.<br />
typealias Index = T<br />
typealias ArraySlice = Range&lt;T&gt;<br />
subscript (position: T) -&gt; T { get }<br />
subscript (_: T._DisabledRangeIndex) -&gt; T { get }</td>
    <td>&nbsp;</td>
    <td>var location: Int<br />
var length: Int</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><ul>
      <li>init(_ x: Range&lt;T&gt;) <br />
        </li>
      <li>init(start: T, end: T) <br />
        </li>
      <li>var isEmpty: Bool { get } </li>
    </ul></td>
    <td>&nbsp;</td>
    <td><ul>
      <li>init()<br />
        </li>
      <li>init(location: Int, length: Int)<br />
      </li>
      <li></li>
    </ul>
      <p>extension _NSRange {<br />
        init(_ x: Range&lt;Int&gt;)<br />
        func toRange() -&gt; Range&lt;Int&gt;?<br />
    }</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><ul>
      <li>typealias Generator = RangeGenerator&lt;T&gt;<br />
    </li>
      <li>func generate() -&gt; RangeGenerator&lt;T&gt;</li>
    </ul></td>
    <td>&nbsp;</td>
    <td><p>&nbsp;</p>
<p>&nbsp;</p>
      <p>extension _NSRange : _ObjectiveCBridgeable {<br />
        }<br />
    typealias NSRange = _NSRange</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>var startIndex: T</p>
    <p>var endIndex: T</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p><br />
    </p>
      <p><br />
    </p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Printable, DebugPrintable</td>
    <td><p>/// A textual representation of `self`.<br />
      var description: String { get }</p>
      <p> /// A textual representation of `self`, suitable for debugging.<br />
    var debugDescription: String { get }</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Range</td>
    <td><br />
func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; [U]</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>extension Range : Reflectable </td>
    <td>func getMirror() -&gt; MirrorType</td>
    <td>&nbsp;</td>
    <td><p>extension _NSRange : Reflectable {</p>
      <p> /// Returns a mirror that reflects `self`.<br />
        func getMirror() -&gt; MirrorType<br />
    }</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>typealias NSRangePointer = UnsafeMutablePointer&lt;NSRange&gt;</p>
<p>func NSMakeRange(loc: Int, len: Int) -&gt; NSRange</p>
<p>func NSMaxRange(range: NSRange) -&gt; Int</p>
<p>func NSLocationInRange(loc: Int, range: NSRange) -&gt; Bool</p>
<p>func NSEqualRanges(range1: NSRange, range2: NSRange) -&gt; Bool</p>
<p>func NSUnionRange(range1: NSRange, range2: NSRange) -&gt; NSRange<br />
  func NSIntersectionRange(range1: NSRange, range2: NSRange) -&gt; NSRange<br />
  func NSStringFromRange(range: NSRange) -&gt; String!<br />
  func NSRangeFromString(aString: String!) -&gt; NSRange</p>
<p>extension NSValue {<br />
  <br />
  init(range: NSRange) -&gt; NSValue<br />
  var rangeValue: NSRange { get }<br />
  }</p>
<p><br />
</p>
<p>/// A generator over the elements of `Range&lt;T&gt;`<br />
struct RangeGenerator&lt;T : ForwardIndexType&gt; </p>
<table width="100%" border="1">
  <tr>
    <td><p>&nbsp;</p>
      <p>: , </p>
      <p>&nbsp;</p></td>
    <td><p>/// The type of element returned by `next()`.<br />
      typealias Element = T</p>
      <p> /// Construct an instance that traverses the elements of `bounds`<br />
        init(_ bounds: Range&lt;T&gt;)</p>
      <p> /// Advance to the next element and return it, or `nil` if no next<br />
        /// element exists.<br />
        mutating func next() -&gt; T?</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>GeneratorType</td>
    <td><p>/// A type whose instances can produce the elements of this<br />
      /// sequence, in order.<br />
      typealias Generator = RangeGenerator&lt;T&gt;</p>
      <p> /// `RangeGenerator` is also a `SequenceType`, so it<br />
        /// `generate`\ 's a copy of itself<br />
        func generate() -&gt; RangeGenerator&lt;T&gt;</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>SequenceType</td>
    <td><p>/// The lower bound of the remaining range.<br />
      var startIndex: T</p>
      <p> /// The upper bound of the remaining range; not included in the<br />
        /// generated sequence.<br />
        var endIndex: T</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>protocol ForwardIndexType : _ForwardIndexType</p>
<p>protocol _ForwardIndexType : _Incrementable</p>
<p>protocol _Incrementable : Equatable</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>return </td>
  </tr>
  <tr>
    <td rowspan="3"><p>closed range</p></td>
    <td>/// Forms a closed range that contains both `start` and `end`.<br />
/// Requres: `start &lt;= end`<br />
func ...&lt;Pos : ForwardIndexType where Pos : Comparable&gt;(start: Pos, end: Pos) -&gt; Range&lt;Pos&gt;</td>
    <td>Pos : ForwardIndexType where Pos : Comparable</td>
    <td rowspan="2">Range&lt;Pos&gt;</td>
  </tr>
  <tr>
    <td><p><br />
      </p>
      <p>/// Forms a closed range that contains both `minimum` and `maximum`.<br />
    func ...&lt;Pos : ForwardIndexType&gt;(minimum: Pos, maximum: Pos) -&gt; Range&lt;Pos&gt;</p></td>
    <td>Pos : ForwardIndexType</td>
  </tr>
  <tr>
    <td>/// Returns a closed interval from `start` through `end`<br />
    func ...&lt;T : Comparable&gt;(start: T, end: T) -&gt; ClosedInterval&lt;T&gt;</td>
    <td>&nbsp;</td>
    <td>ClosedInterval&lt;T&gt;</td>
  </tr>
  <tr>
    <td rowspan="3">half-open range</td>
    <td>/// Forms a half-open range that contains `minimum`, but not<br />
/// `maximum`.<br />
func ..&lt;&lt;Pos : ForwardIndexType&gt;(minimum: Pos, maximum: Pos) -&gt; Range&lt;Pos&gt;</td>
    <td>Pos : ForwardIndexType</td>
    <td rowspan="2">Range&lt;Pos&gt;</td>
  </tr>
  <tr>
    <td><p><br />
      </p>
      <p>/// Forms a half-open range that contains `start`, but not<br />
        /// `end`.  Requires: `start &lt;= end`<br />
    func ..&lt;&lt;Pos : ForwardIndexType where Pos : Comparable&gt;(start: Pos, end: Pos) -&gt; Range&lt;Pos&gt;</p></td>
    <td><p>Pos : ForwardIndexType where Pos : Comparable</p></td>
  </tr>
  <tr>
    <td>/// Returns a half-open interval from `start` to `end`<br />
    func ..&lt;&lt;T : Comparable&gt;(start: T, end: T) -&gt; HalfOpenInterval&lt;T&gt;</td>
    <td>T : Comparable</td>
    <td>HalfOpenInterval&lt;T&gt;</td>
  </tr>
</table>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p>&nbsp;</p>
</body>
</html>
