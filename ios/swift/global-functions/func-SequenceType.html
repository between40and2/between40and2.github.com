<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>func-SequenceType</title>
</head>

<body>
<h1>func-SequenceType</h1>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td rowspan="2">func contains</td>
    <td>&lt;S : SequenceType where S.Generator.Element : Equatable&gt;</td>
    <td>(seq: S, x: S.Generator.Element) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td><p>&lt;S : SequenceType, L : BooleanType&gt;</p></td>
    <td>(seq: S, predicate: @noescape (S.Generator.Element) -&gt; L)</td>
    <td> -&gt; Bool</td>
  </tr>
  <tr>
    <td rowspan="2">func equal</td>
    <td>&lt;S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element, S1.Generator.Element : Equatable&gt;</td>
    <td>(a1: S1, a2: S2) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td><p>&lt;S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element&gt;</p></td>
    <td>(a1: S1, a2: S2, isEquivalent: @noescape (S1.Generator.Element, S1.Generator.Element) -&gt; Bool) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td rowspan="2">func lexicographicalCompare</td>
    <td>&lt;S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element, S1.Generator.Element : Comparable&gt;</td>
    <td>(a1: S1, a2: S2) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td><p>&lt;S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element&gt;</p></td>
    <td>(a1: S1, a2: S2, isOrderedBefore less: @noescape (S1.Generator.Element, S1.Generator.Element) -&gt; Bool) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>func reduce&lt;S : SequenceType, U&gt;(sequence: S, initial: U, combine: @noescape (U, S.Generator.Element) -&gt; U) -&gt; U</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>func startsWith</td>
    <td><p>&lt;S0 : SequenceType, S1 : SequenceType where S0.Generator.Element == S0.Generator.Element, S0.Generator.Element : Equatable&gt;</p></td>
    <td>(s: S0, prefix: S1) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td>func startsWith</td>
    <td><p>&lt;S0 : SequenceType, S1 : SequenceType where S0.Generator.Element == S0.Generator.Element&gt;</p></td>
    <td>(s: S0, prefix: S1, isEquivalent: @noescape (S0.Generator.Element, S0.Generator.Element) -&gt; Bool) </td>
    <td>-&gt; Bool</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>func underestimateCount&lt;T : SequenceType&gt;(x: T) -&gt; Int</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p></p>
<p></p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>func enumerate</td>
    <td>&lt;Seq : SequenceType&gt;</td>
    <td>(base: Seq)</td>
    <td> -&gt; EnumerateSequence&lt;Seq&gt;</td>
  </tr>
  <tr>
    <td>func filter</td>
    <td>&lt;S : SequenceType&gt;</td>
    <td>(source: S, includeElement: (S.Generator.Element) -&gt; Bool) </td>
    <td>-&gt; [S.Generator.Element]</td>
  </tr>
  <tr>
    <td>func maxElement</td>
    <td>&lt;R : SequenceType where R.Generator.Element : Comparable&gt;</td>
    <td>(elements: R) </td>
    <td>-&gt; R.Generator.Element</td>
  </tr>
  <tr>
    <td>func sorted</td>
    <td>&lt;C : SequenceType where C.Generator.Element : Comparable&gt;</td>
    <td>(source: C) </td>
    <td>-&gt; [C.Generator.Element]</td>
  </tr>
  <tr>
    <td>func sorted</td>
    <td><p>&lt;C : SequenceType&gt;</p></td>
    <td>(source: C, isOrderedBefore: (C.Generator.Element, C.Generator.Element) -&gt; Bool) </td>
    <td>-&gt; [C.Generator.Element]</td>
  </tr>
</table>
<p></p>
<p>map and flatMap</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td rowspan="3">func flatMap</td>
    <td><p>&lt;T, U&gt;      </p></td>
    <td>(x: T?, f: @noescape (T) -&gt; U?) </td>
    <td>-&gt; U?</td>
  </tr>
  <tr>
    <td>&lt;C : CollectionType, T&gt;</td>
    <td>(source: C, transform: (C.Generator.Element) -&gt; [T])</td>
    <td> -&gt; [T]</td>
  </tr>
  <tr>
    <td>&lt;S : SequenceType, T&gt;</td>
    <td>(source: S, transform: @noescape (S.Generator.Element) -&gt; [T])</td>
    <td> -&gt; [T]</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td rowspan="3">func map</td>
    <td><p>&lt;T, U&gt;</p></td>
    <td>(x: T?, f: @noescape (T) -&gt; U)</td>
    <td> -&gt; U?</td>
  </tr>
  <tr>
    <td>&lt;S : SequenceType, T&gt;</td>
    <td>(source: S, transform: (S.Generator.Element) -&gt; T)</td>
    <td> -&gt; [T]</td>
  </tr>
  <tr>
    <td>&lt;C : CollectionType, T&gt;</td>
    <td>(source: C, transform: (C.Generator.Element) -&gt; T)</td>
    <td> -&gt; [T]</td>
  </tr>
</table>
<p></p>
<p></p>
</body>
</html>
