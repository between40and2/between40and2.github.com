<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Ruby-Ref-String</title>
</head>

<body>
<h1>Ruby-Ref-String</h1>
<h2><a href="http://ruby-doc.org/core-1.9.3/String.html">String</a></h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>str % arg =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&quot;%05d&quot; % 123                       #=&gt; &quot;00123&quot;<br />
    &quot;%-5s: %08x&quot; % [ &quot;ID&quot;, self.id ]   #=&gt; &quot;ID   : 200e14d6&quot;</td>
  </tr>
  <tr>
    <td>str * integer =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>str + other_str =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>str &lt;&lt; fixnum =&gt; str <br />
      concat(fixnum) =&gt; str<br />
      str &lt;&lt; obj =&gt; str<br />
    concat(obj) =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>a = &quot;hello &quot;<br />
      a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;<br />
    a.concat(33)   #=&gt; &quot;hello world!&quot;</td>
  </tr>
  <tr>
    <td>str &lt;=&gt; other_str =&gt; -1, 0, +1</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>str == obj =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>str =~ obj =&gt; fixnum or nil</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>str[fixnum] =&gt; fixnum or nil <br />
      str[fixnum, fixnum] =&gt; new_str or nil<br />
      str[range] =&gt; new_str or nil<br />
      str[regexp] =&gt; new_str or nil<br />
      str[regexp, fixnum] =&gt; new_str or nil<br />
      str[other_str] =&gt; new_str or nil<br />
      slice(fixnum) =&gt; fixnum or nil<br />
      slice(fixnum, fixnum) =&gt; new_str or nil<br />
      slice(range) =&gt; new_str or nil<br />
      slice(regexp) =&gt; new_str or nil<br />
      slice(regexp, fixnum) =&gt; new_str or nil<br />
    slice(other_str) =&gt; new_str or nil</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><p>str[fixnum] = fixnum <br />
      str[fixnum] = new_str<br />
      str[fixnum, fixnum] = new_str<br />
      str[range] = aString<br />
      str[regexp] = new_str<br />
      str[regexp, fixnum] = new_str<br />
    str[other_str] = new_str</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>bytes =&gt; anEnumerator <br />
    bytes {|fixnum| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>length =&gt; integer</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>capitalize =&gt; new_str</p>
    <p>capitalize! =&gt; str or nil</p>
    <p>downcase =&gt; new_str</p>
    <p>downcase! =&gt; str or nil</p>
    <p>upcase =&gt; new_str</p>
    <p>upcase! =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>casecmp(other_str) =&gt; -1, 0, +1</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>center(integer, padstr) =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>chars =&gt; anEnumerator<br />
    chars {|substr| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>chomp(separator=$/) =&gt; new_str</p>
    <p>chomp!(separator=$/) =&gt; str or nil</p>
    <p>chop =&gt; new_str</p>
    <p>chop! =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>count([other_str]+) =&gt; fixnum</td>
    <td>&nbsp;</td>
    <td><p>a = &quot;hello world&quot;<br />
      a.count &quot;lo&quot;            #=&gt; 5<br />
      a.count &quot;lo&quot;, &quot;o&quot;       #=&gt; 2<br />
      a.count &quot;hello&quot;, &quot;^l&quot;   #=&gt; 4<br />
    a.count &quot;ej-m&quot;          #=&gt; 4</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>crypt(other_str) =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>delete([other_str]+) =&gt; new_str</p>
    <p>delete!([other_str]+&gt;) =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>dump =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>each(separator=$/) {|substr| block } =&gt; str <br />
    each_line(separator=$/) {|substr| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>each_byte {|fixnum| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td><p>&quot;hello&quot;.each_byte {|c| print c, ' ' }</p>
    <p>104 101 108 108 111</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>each_char {|cstr| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td><p>&quot;hello&quot;.each_char {|c| print c, ' ' }</p>
    <p>h e l l o</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>empty? =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>end_with?([suffix]+) =&gt; true or false</p>
    <p>start_with?([prefix]+) =&gt; true or false</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>eql?(other) =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>gsub(pattern, replacement) =&gt; new_str <br />
    gsub(pattern) {|match| block } =&gt; new_str</p>
    <p>&nbsp;</p>
    <p>gsub!(pattern, replacement) =&gt; str or nil<br />
    gsub!(pattern) {|match| block } =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td><p>&quot;hello&quot;.gsub(/[aeiou]/, '*')              #=&gt; &quot;h*ll*&quot;<br />
      &quot;hello&quot;.gsub(/([aeiou])/, '&lt;\1&gt;')         #=&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;<br />
    &quot;hello&quot;.gsub(/./) {|s| s[0].to_s + ' '}   #=&gt; &quot;104 101 108 108 111 &quot;</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>hash =&gt; fixnum</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>hex =&gt; integer</p>
    <p>oct =&gt; integer</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>include? other_str =&gt; true or false <br />
    include? fixnum =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>index(substring [, offset]) =&gt; fixnum or nil <br />
      index(fixnum [, offset]) =&gt; fixnum or nil<br />
    index(regexp [, offset]) =&gt; fixnum or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>replace(other_str) =&gt; str</td>
    <td>&nbsp;</td>
    <td>s = &quot;hello&quot;         #=&gt; &quot;hello&quot;<br />
    s.replace &quot;world&quot;   #=&gt; &quot;world&quot;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>insert(index, other_str) =&gt; str</td>
    <td>&nbsp;</td>
    <td><p>&quot;abcd&quot;.insert(0, 'X')    #=&gt; &quot;Xabcd&quot;<br />
      &quot;abcd&quot;.insert(3, 'X')    #=&gt; &quot;abcXd&quot;<br />
      &quot;abcd&quot;.insert(4, 'X')    #=&gt; &quot;abcdX&quot;<br />
      &quot;abcd&quot;.insert(-3, 'X')   #=&gt; &quot;abXcd&quot;<br />
    &quot;abcd&quot;.insert(-1, 'X')   #=&gt; &quot;abcdX&quot;</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>inspect =&gt; string</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>intern =&gt; symbol <br />
    to_sym =&gt; symbol</td>
    <td>&nbsp;</td>
    <td><p>&quot;Koala&quot;.intern         #=&gt; :Koala<br />
      s = 'cat'.to_sym       #=&gt; :cat<br />
      s == :cat              #=&gt; true<br />
      s = '@cat'.to_sym      #=&gt; :@cat<br />
    s == :@cat             #=&gt; true</p>
    <p>'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>length =&gt; integer</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>lines(separator=$/) =&gt; anEnumerator click to toggle source<br />
    lines(separator=$/) {|substr| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>ljust(integer, padstr=' ') =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>lstrip =&gt; new_str</p>
    <p>lstrip! =&gt; self or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>match(pattern) =&gt; matchdata or nil</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>succ =&gt; new_str <br />
    next =&gt; new_str</p>
    <p>succ! =&gt; str <br />
    next! =&gt; str</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>partition(sep) =&gt; [head, sep, tail]</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>replace(other_str) =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>reverse =&gt; new_str</p>
    <p>reverse! =&gt; str</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>rindex(substring [, fixnum]) =&gt; fixnum or nil <br />
      rindex(fixnum [, fixnum]) =&gt; fixnum or nil<br />
    rindex(regexp [, fixnum]) =&gt; fixnum or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>rjust(integer, padstr=' ') =&gt; new_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>rpartition(sep) =&gt; [head, sep, tail]</td>
    <td>&nbsp;</td>
    <td>&quot;hello&quot;.rpartition(&quot;l&quot;)         #=&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]<br />
    &quot;hello&quot;.rpartition(&quot;x&quot;)         #=&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>rstrip =&gt; new_str</p>
    <p>rstrip! =&gt; self or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>scan(pattern) =&gt; array <br />
    scan(pattern) {|match, ...| block } =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>slice!(fixnum) =&gt; fixnum or nil <br />
      slice!(fixnum, fixnum) =&gt; new_str or nil<br />
      slice!(range) =&gt; new_str or nil<br />
      slice!(regexp) =&gt; new_str or nil<br />
    slice!(other_str) =&gt; new_str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>split(pattern=$;, [limit]) =&gt; anArray</td>
    <td>&nbsp;</td>
    <td><p>&quot; now's  the time&quot;.split        #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]<br />
      &quot; now's  the time&quot;.split(' ')   #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]<br />
      &quot; now's  the time&quot;.split(/ /)   #=&gt; [&quot;&quot;, &quot;now's&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]<br />
      &quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) #=&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]<br />
      &quot;hello&quot;.split(//)               #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]<br />
      &quot;hello&quot;.split(//, 3)            #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]<br />
      &quot;hi mom&quot;.split(%r{\s*})         #=&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]</p>
      <p>&quot;mellow yellow&quot;.split(&quot;ello&quot;)   #=&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]<br />
        &quot;1,2,,3,4,,&quot;.split(',')         #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;]<br />
        &quot;1,2,,3,4,,&quot;.split(',', 4)      #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3,4,,&quot;]<br />
    &quot;1,2,,3,4,,&quot;.split(',', -4)     #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>squeeze([other_str]*) =&gt; new_str</p>
    <p>squeeze!([other_str]*) =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>strip =&gt; new_str</p>
    <p>strip! =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>sub(pattern, replacement) =&gt; new_str <br />
    sub(pattern) {|match| block } =&gt; new_str</p>
    <p>sub!(pattern, replacement) =&gt; str or nil <br />
    sub!(pattern) {|match| block } =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>sum(n=16) =&gt; integer</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>swapcase =&gt; new_str</p>
    <p>swapcase! =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>to_f =&gt; float</p>
    <p>to_i(base=10) =&gt; integer</p>
    <p>&nbsp;</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>to_s =&gt; str <br />
    to_str =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>tr(from_str, to_str) =&gt; new_str</p>
    <p>tr!(from_str, to_str) =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td><p>&quot;hello&quot;.tr('aeiou', '*')    #=&gt; &quot;h*ll*&quot;<br />
      &quot;hello&quot;.tr('^aeiou', '*')   #=&gt; &quot;*e**o&quot;<br />
      &quot;hello&quot;.tr('el', 'ip')      #=&gt; &quot;hippo&quot;<br />
    &quot;hello&quot;.tr('a-y', 'b-z')    #=&gt; &quot;ifmmp&quot;</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p>tr_s(from_str, to_str) =&gt; new_str</p>
    <p>tr_s!(from_str, to_str) =&gt; str or nil</p></td>
    <td>&nbsp;</td>
    <td>&quot;hello&quot;.tr_s('l', 'r')     #=&gt; &quot;hero&quot;<br />
      &quot;hello&quot;.tr_s('el', '*')    #=&gt; &quot;h*o&quot;<br />
    &quot;hello&quot;.tr_s('el', 'hx')   #=&gt; &quot;hhxo&quot;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>unpack(format) =&gt; anArray</td>
    <td>&nbsp;</td>
    <td>&quot;abc \00\\00aabc \00\\00&quot;&quot;.unpack('A6Z6')   #=&gt; [&quot;abc&quot;, &quot;abc &quot;]<br />
      &quot;abc \00\\00&quot;&quot;.unpack('a3a3')           #=&gt; [&quot;abc&quot;, &quot; \000\000&quot;]<br />
      &quot;abc \00aabc \00&quot;&quot;.unpack('Z*Z*')       #=&gt; [&quot;abc &quot;, &quot;abc &quot;]<br />
      &quot;aa&quot;.unpack('b8B8')                 #=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]<br />
      &quot;aaa&quot;.unpack('h2H2c')               #=&gt; [&quot;16&quot;, &quot;61&quot;, 97]<br />
      &quot;\xfe\xff\xfe\xff&quot;.unpack('sS')     #=&gt; [-2, 65534]<br />
      &quot;now=20is&quot;.unpack('M*')             #=&gt; [&quot;now is&quot;]<br />
    &quot;whole&quot;.unpack('xax2aX2aX1aX2a')    #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>upto(other_str, exclusive=false) {|s| block } =&gt; str </td>
    <td>&nbsp;</td>
    <td>&quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, ' ' }<br />
      for s in &quot;a8&quot;..&quot;b6&quot;<br />
print s, ' '<br />
end</td>
  </tr>
</table>
<p>&nbsp;</p>
<h2><a href="http://ruby-doc.org/core-1.9.3/Regexp.html">Regexp</a></h2>
<p>A Regexp holds a regular expression, used to match a pattern against strings. Regexps are created using the /.../ and %r{...} literals, and by the Regexp::new constructor.</p>
<h3>Constants</h3>
<ul>
  <li>EXTENDED</li>
  <li>IGNORECASE</li>
  <li>MULTILINE</li>
</ul>
<h3>Public Class Methods</h3>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>escape(str) =&gt; a_str <br />
    quote(str) =&gt; a_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>Regexp.escape('\*?{}.')   #=&gt; \\\\\*\?\{\}\.</td>
  </tr>
  <tr>
    <td>last_match =&gt; matchdata <br />
    last_match(fixnum) =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>/c(.)t/ =~ 'cat'       #=&gt; 0<br />
      Regexp.last_match      #=&gt; #&lt;MatchData:0x401b3d30&gt;<br />
      Regexp.last_match(0)   #=&gt; &quot;cat&quot;<br />
      Regexp.last_match(1)   #=&gt; &quot;a&quot;<br />
    Regexp.last_match(2)   #=&gt; nil</p></td>
  </tr>
  <tr>
    <td>new(string [, options [, lang]]) =&gt; regexp <br />
      new(regexp) =&gt; regexp<br />
      compile(string [, options [, lang]]) =&gt; regexp<br />
    compile(regexp) =&gt; regexp</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>r1 = Regexp.new('^a-z+:\s+\w+')           #=&gt; /^a-z+:\s+\w+/<br />
      r2 = Regexp.new('cat', true)               #=&gt; /cat/i<br />
      r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x<br />
    r4 = Regexp.new(r2)                        #=&gt; /cat/i</p></td>
  </tr>
  <tr>
    <td>union(pat1, pat2, ...) =&gt; new_regexp <br />
    union(pats_ary) =&gt; new_regexp</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>Regexp.union                         #=&gt; /(?!)/<br />
      Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/<br />
      Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/<br />
      Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/<br />
      Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/<br />
    Regexp.union(/dogs/, /cats/)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/</td>
  </tr>
</table>
<h3>Public Instance Methods</h3>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>rxp == other_rxp =&gt; true or false<br />
    eql?(other_rxp) =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>/abc/  == /abc/   #=&gt; false<br />
      /abc/  == /abc/   #=&gt; false<br />
    /abc/ == /abc/   #=&gt; false</td>
  </tr>
  <tr>
    <td>rxp === str =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><p>#=~</p>
      <p>match(str) =&gt; matchdata or nil</p>
    <p>&nbsp;</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>/(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;</td>
  </tr>
  <tr>
    <td>casefold? =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>hash =&gt; fixnum</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>inspect =&gt; string</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>kcode =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>options =&gt; fixnum</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>Regexp::IGNORECASE                  #=&gt; 1<br />
      Regexp::EXTENDED                    #=&gt; 2<br />
      Regexp::MULTILINE                   #=&gt; 4</p>
      <p>/cat/.options                       #=&gt; 128<br />
        /cat/x.options                     #=&gt; 131<br />
        Regexp.new('cat', true).options     #=&gt; 129<br />
        Regexp.new('cat', 0, 's').options   #=&gt; 384</p>
      <p>r = /cat/x<br />
    Regexp.new(r.source, r.options)     #=&gt; /cat/ix</p></td>
  </tr>
  <tr>
    <td>source =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>/ab+c/x.source   #=&gt; &quot;ab+c&quot;</td>
  </tr>
  <tr>
    <td>to_s =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>~ rxp =&gt; integer or nil</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>$_ = &quot;input data&quot;<br />
    ~ /at/   #=&gt; 7</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="http://ruby-doc.org/core-1.8.7/MatchData.html">MatchData</a></h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>mtch[i] =&gt; obj <br />
      mtch[start, length] =&gt; array<br />
    mtch[range] =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)<br />
      m[0]       #=&gt; &quot;HX1138&quot;<br />
      m[1, 2]    #=&gt; [&quot;H&quot;, &quot;X&quot;]<br />
      m[1..3]    #=&gt; [&quot;H&quot;, &quot;X&quot;, &quot;113&quot;]<br />
    m[-3, 2]   #=&gt; [&quot;X&quot;, &quot;113&quot;]</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>begin(n) =&gt; integer</td>
    <td>&nbsp;</td>
    <td>m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)<br />
      m.begin(0)   #=&gt; 1<br />
    m.begin(2)   #=&gt; 2</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>end(n) =&gt; integer</td>
    <td>&nbsp;</td>
    <td>m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)<br />
      m.end(0)   #=&gt; 7<br />
    m.end(2)   #=&gt; 3</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>captures =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>inspect =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>length =&gt; integer <br />
    size =&gt; integer</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>offset(n) =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>post_match =&gt; str</td>
    <td>pre_match =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>select{|obj| block} =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>string =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>to_a =&gt; anArray</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>to_s =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>values_at([index]*) =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
</body>
</html>
