<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Regexp</title>
</head>

<body>
<h2><a href="http://ruby-doc.org/core-1.9.3/Regexp.html">Regexp</a></h2>
<p>A Regexp holds a regular expression, used to match a pattern against strings. Regexps are created using the /.../ and %r{...} literals, and by the Regexp::new constructor.</p>
<h3>Constants</h3>
<ul>
  <li>EXTENDED</li>
  <li>IGNORECASE</li>
  <li>MULTILINE</li>
</ul>
<h3>Public Class Methods</h3>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>escape(str) =&gt; a_str <br />
      quote(str) =&gt; a_str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>Regexp.escape('\*?{}.')   #=&gt; \\\\\*\?\{\}\.</td>
  </tr>
  <tr>
    <td>last_match =&gt; matchdata <br />
      last_match(fixnum) =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>/c(.)t/ =~ 'cat'       #=&gt; 0<br />
      Regexp.last_match      #=&gt; #&lt;MatchData:0x401b3d30&gt;<br />
      Regexp.last_match(0)   #=&gt; &quot;cat&quot;<br />
      Regexp.last_match(1)   #=&gt; &quot;a&quot;<br />
      Regexp.last_match(2)   #=&gt; nil</p></td>
  </tr>
  <tr>
    <td>new(string [, options [, lang]]) =&gt; regexp <br />
      new(regexp) =&gt; regexp<br />
      compile(string [, options [, lang]]) =&gt; regexp<br />
      compile(regexp) =&gt; regexp</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>r1 = Regexp.new('^a-z+:\s+\w+')           #=&gt; /^a-z+:\s+\w+/<br />
      r2 = Regexp.new('cat', true)               #=&gt; /cat/i<br />
      r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x<br />
      r4 = Regexp.new(r2)                        #=&gt; /cat/i</p></td>
  </tr>
  <tr>
    <td>union(pat1, pat2, ...) =&gt; new_regexp <br />
      union(pats_ary) =&gt; new_regexp</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>Regexp.union                         #=&gt; /(?!)/<br />
      Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/<br />
      Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/<br />
      Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/<br />
      Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/<br />
      Regexp.union(/dogs/, /cats/)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/</td>
  </tr>
</table>
<h3>Public Instance Methods</h3>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>rxp == other_rxp =&gt; true or false<br />
      eql?(other_rxp) =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>/abc/  == /abc/   #=&gt; false<br />
      /abc/  == /abc/   #=&gt; false<br />
      /abc/ == /abc/   #=&gt; false</td>
  </tr>
  <tr>
    <td>rxp === str =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><p>#=~</p>
      <p>match(str) =&gt; matchdata or nil</p>
      <p>&nbsp;</p></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>/(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;</td>
  </tr>
  <tr>
    <td>casefold? =&gt; true or false</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>hash =&gt; fixnum</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>inspect =&gt; string</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>kcode =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>options =&gt; fixnum</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>Regexp::IGNORECASE                  #=&gt; 1<br />
      Regexp::EXTENDED                    #=&gt; 2<br />
      Regexp::MULTILINE                   #=&gt; 4</p>
      <p>/cat/.options                       #=&gt; 128<br />
        /cat/x.options                     #=&gt; 131<br />
        Regexp.new('cat', true).options     #=&gt; 129<br />
        Regexp.new('cat', 0, 's').options   #=&gt; 384</p>
      <p>r = /cat/x<br />
        Regexp.new(r.source, r.options)     #=&gt; /cat/ix</p></td>
  </tr>
  <tr>
    <td>source =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>/ab+c/x.source   #=&gt; &quot;ab+c&quot;</td>
  </tr>
  <tr>
    <td>to_s =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>~ rxp =&gt; integer or nil</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>$_ = &quot;input data&quot;<br />
      ~ /at/   #=&gt; 7</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="http://ruby-doc.org/core-1.8.7/MatchData.html">MatchData</a></h2>
<p>&nbsp;</p>
<table width="100%" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>mtch[i] =&gt; obj <br />
      mtch[start, length] =&gt; array<br />
      mtch[range] =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td><p>m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)<br />
      m[0]       #=&gt; &quot;HX1138&quot;<br />
      m[1, 2]    #=&gt; [&quot;H&quot;, &quot;X&quot;]<br />
      m[1..3]    #=&gt; [&quot;H&quot;, &quot;X&quot;, &quot;113&quot;]<br />
      m[-3, 2]   #=&gt; [&quot;X&quot;, &quot;113&quot;]</p></td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>begin(n) =&gt; integer</td>
    <td>&nbsp;</td>
    <td>m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)<br />
      m.begin(0)   #=&gt; 1<br />
      m.begin(2)   #=&gt; 2</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>end(n) =&gt; integer</td>
    <td>&nbsp;</td>
    <td>m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)<br />
      m.end(0)   #=&gt; 7<br />
      m.end(2)   #=&gt; 3</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>captures =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>inspect =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>length =&gt; integer <br />
      size =&gt; integer</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>offset(n) =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>post_match =&gt; str</td>
    <td>pre_match =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>select{|obj| block} =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>string =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>to_a =&gt; anArray</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>to_s =&gt; str</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>values_at([index]*) =&gt; array</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p></p>
</body>
</html>
